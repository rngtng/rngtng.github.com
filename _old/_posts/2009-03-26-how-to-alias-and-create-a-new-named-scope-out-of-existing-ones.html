---
layout: post
status: publish
published: true
title: How to alias and create a new named scope out of existing ones
author:
  display_name: tobi
  login: tobi
  email: t.bielohlawek@gmail.com
  url: http://
author_login: tobi
author_email: t.bielohlawek@gmail.com
author_url: http://
wordpress_id: 8
wordpress_url: http://urangatang.wordpress.com/?p=8
date: '2009-03-26 15:32:22 +0000'
date_gmt: '2009-03-26 14:32:22 +0000'
categories:
- Ruby, Rails & Co.
tags:
- beauty of code
- hint
- named
- scope
comments:
- id: 53
  author: Michael Thompson
  author_email: michael@bluebuttonpress.com
  author_url: ''
  date: '2009-09-18 09:09:53 +0000'
  date_gmt: '2009-09-18 08:09:53 +0000'
  content: 'Thanks, this was useful. I had a bunch of anonymous named scopes I needed
    to chain together, but with OR, rather than AND. It was simple to create a new
    scope using the collection of #scope(:find)[:conditions] joined with " OR ".'
- id: 529
  author: David Ongaro
  author_email: david.ongaro@hamburg.de
  author_url: ''
  date: '2010-06-04 14:05:38 +0000'
  date_gmt: '2010-06-04 12:05:38 +0000'
  content: "Nice. Even though just defining a method like\r\n\r\n  def self.has_moo_and_foo\r\n
    \   has_moo. has_foo\r\n  end\r\n\r\nalso works, I find the named_scope syntax
    more appealing, because one can scan the named scopes in one sight. (And they
    also show up in Fu.scopes).\r\n\r\nWhen you define the scopes in the right order,
    the lambda gets superflous though. So\r\n\r\n  named_scope :has_moo_and_foo, has_moo.has_foo.scope(:find)\r\n\r\nis
    enough. But default_scope conditions are duplicated in this way (with or without
    lambda). Even though this doesn't might hurt it seems to be saver to just exclude
    them:\r\n\r\n  named_scope :has_moo_and_foo, with_exclusive_scope { has_moo.has_foo.scope(:find)
    }"
- id: 651
  author: scragz
  author_email: reg@scragz.com
  author_url: http://scragz.com/
  date: '2011-02-07 05:17:43 +0000'
  date_gmt: '2011-02-07 03:17:43 +0000'
  content: "I wanted to just make some simple aliases like alias_method so I whipped
    this up:\r\n\r\nmodule ActiveRecord\r\n  class Base\r\n    def self.alias_named_scope(alias_scope,
    original_scope)\r\n      named_scope alias_scope, lambda { self.send(original_scope).scope(:find)
    }\r\n    end\r\n  end\r\nend\r\n"
---
<p><a href="http://www.pathf.com/blogs/2008/06/named-scopes-are-awesome/">Named</a> <a href="http://railscasts.com/episodes/108-named-scope">scopes</a> in Rails are just awesome. They so much DRY and beautify your code! But did you ever had the trouble to create a new named_scope out of others? E.g. aliasing multiple ones to a new one. Luckily I now figured out how this works in a nice way.<br />
The magic key is the method <em><code>scope( :find )</code></em></p>
<p>This method called on a Scope class returns the Hash used for the ActiveRecord <code>.find()</code> call. First it's a nice way to debug your scopes, second it's perfect for our need to chain multiple scoped into one. Check this out:</p>
<p>[ruby]<br />
class Fu < ActiveRecord::Base<br />
named_scope :has_moo,  :conditions => { :moo => true }<br />
named_scope :has_foo,  :conditions => { :foo => true }</p>
<p>named_scope :has_moo_and_foo, lambda { has_moo.has_foo.scope(:find) }<br />
end<br />
[/ruby]</p>
<p>We chain the two scoped <code>has_moo</code> and <code>has_foo</code> together into a new one called <code>has_moo_and_foo</code>. As the return value can only be a Hash we use the above mentioned scope(:find) to transform it into one.</p>
<p>Now this works:</p>
<p>[ruby]Fu.has_moo_and_foo.all[/ruby]</p>
<p>Sweet! Imagine how great this would be if we can return a scope object instead of a hash as well??</p>
<p>See my <a href="http://pastie.org/427839">pastie here</a> too.</p>
