---
layout: post
status: publish
published: true
title: 'Introducing: Vault Project or How to setup an Encryption Server'
author:
  display_name: admin
  login: admin
  email: t.bielohlawek@web.de
  url: http://
author_login: admin
author_email: t.bielohlawek@web.de
author_url: http://
wordpress_id: 849
wordpress_url: http://www.rngtng.com/?p=849
date: '2016-04-01 07:36:51 +0000'
date_gmt: '2016-04-01 06:36:51 +0000'
categories:
- Happy Hacking
tags:
- howto
- setup
- vault
- security
- git
- credentials
- secret data
comments: []
---
<p><img class="alignnone size-full wp-image-850" src="http://www.rngtng.com/files/2015/08/Screen-Shot-2015-08-07-at-16.08.24.png" alt="" width="555" height="129" /></p>
<p>Let's talk about credentials. Credentials! Who doesn't work without any secret data which should never go public? Sure, sure, we'd never share those secrets public, but then there's git, and github and.. BAAMM.. credentials exposed. Upps!</p>
<p>To avoid this, it's common sense to <strong>NOT</strong> checkin any credentials. NEVER. EVER. We make use of <code>.gitignore</code>, cfg templates and placeholders. But nevertheless it's a hassle, especially when working in a team, where a credential exchange is sometimes required. In past, I preferred the solution where an encryption server in a save environment took care about encrypting/decrypting data. Once the data is encrypted, it's save to checkin, store and share in the same way like any other data. Only users (or systems) with access rights for the encryption server can decrypt the data. Instant WIN! But how to setup such a server?</p>
<h2>Introducing: Vault Project</h2>
<p>I recently came across the <a href="https://vaultproject.io">Vault Project</a> which exactly meet all my needs. In addition, it's open source, simple to use and comes with very good documentation and tutorials. Nevertheless, I couldn't find all the steps required to setup an encryption server in one place, so here they are:</p>
<h3>How to setup an Encryption server with Vault</h3>
<p>First, setup a new vault server on a remote machine by following those steps:</p>
<ul>
<li>
<ol>
<li>Create a config file <a href="https://vaultproject.io/docs/config">docs</a></li>
</ol>
<p><code>touch vault.cfg</code></p>
<p>For our case we just need a simple file backend and expose the vault via tcp</p>
</li>
</ul>
<pre><code>backend "file" {
  path = "/Users/<username>/.vaultstore"
}


listener "tcp" {
  address = "127.0.0.1:8200"
  tls_disable = 1
}
</code></pre>
<p>See the <a href="https://vaultproject.io/docs/config">vault config docs</a> for other options.</p>
<ul>
<li>
<ol>
<li>Now start the server ...</li>
</ol>
<p><code>vault server -config vault.cfg</code></p>
</li>
<li>
<ol>
<li>... and run the init procedure: <a href="https://vaultproject.io/docs">docs</a></li>
</ol>
<p><code>vault init -address=http://127.0.0.1:8200</code></p>
<p>This will output five keys and a root token. Make sure to keep those keys save, once lost you wouldn't be able to unseal your vault, and therefore gain access. The root token is needed to authenticate against the server. To remove the need of passing in the host address all the time, you can set the value with VAULT_ADDR too: <code>export VAULT_ADDR=http://127.0.0.1:8200</code></p>
</li>
<li>
<ol>
<li>Unseal vault <a href="https://vaultproject.io/docs/concepts/seal.html">docs</a></li>
</ol>
<p>On start, the vault is sealed, and can only be opened with the keys generated at the very beginning. Unseal is done with:</p>
<p><code>vault unseal</code></p>
<p>Execute this three times, and enter a different key each time.</p>
</li>
</ul>
<p>DONE! Now the server is up and running and you can connect from you local machine to the vault.</p>
<ul>
<li>
<ol>
<li>Authenticate with the server</li>
</ol>
<p>The vault only accepts authenticated connections, for that create a auth token with:</p>
<p><code>vault auth</code></p>
<p>Enter the root token-key obtained from step 1. Later, I'd strongly recommend to use a non-root token.</p>
</li>
<li>
<ol>
<li>Enable github auth backend <a href="https://vaultproject.io/docs/auth/github.html">docs</a></li>
</ol>
<p>In order to allow other people access to the vault and decrypt data, it's the easiest to enable github authentication. In this case, every user part to a specific github team is able to obtain an auth-token themselves.</p>
<p>Enable github auth:</p>
<p><code>vault auth-enable github</code></p>
<p>Register github org:<br />
<code>vault write auth/github/config organization=<your org name></code></p>
<p>...and a team:<br />
<code>vault write auth/github/map/teams/<your team name> value=root</code></p>
<p>Now, any team member can get access to the vault with a <a href="https://github.com/settings/tokens">github token</a>:<br />
<code>vault auth -method=github token=<github token></code></p>
<p>Whereas <code><github token></code> only requires the 'read:org' scope to be granted. Once auth is complete the actual vault token will be stored in <code>~/.vault-token</code> and allows the user to connect to the vault.</p>
</li>
<li>
<p>7.Enable transit backend <a href="https://vaultproject.io/docs/secrets/transit">docs</a></p>
<p>Per default, vault stores data associated with a key. But for our case, we want to encrypt data on the fly and manage storage within our SCM instead. Encryption only is enabled with the 'tranist backend':</p>
<p><code>vault mount transit</code></p>
<p>Add a key name to generate an encryption key:</p>
<p><code>vault write -f transit/keys/<key name></code></p>
<p>The actual encryption key can be retrieved via:<br />
<code>vault read --format=json transit/raw/<key name></code></p>
</li>
</ul>
<p>DONE! Now the encryption server is ready to encrypt. For this I used json as response format and <a href="http://stedolan.github.io/jq/">jq</a> to extract the data.</p>
<ul>
<li>1.Encrypt:</li>
</ul>
<pre><code>echo -n "<your secret data>" | base64 | vault write --format=json transit/encrypt/<key name> plaintext=- | jq -r .data.ciphertext
</code></pre>
<ul>
<li>2.Decrypt:</li>
</ul>
<pre><code>vault write --format=json transit/decrypt/<key name> ciphertext=<your ciphertext> | jq -r .data.plaintext | base64 -D
</code></pre>
<p>Finally, let's create some bash functions to make life easy:</p>
<pre><code>export VAULT_ADDR="<you server IP:PORT>"
export VAULT_KEY="<key name>"

function _encrypt {
  base64 | vault write --format=json transit/encrypt/$VAULT_KEY plaintext=- | jq -r .data.ciphertext
}

function _decrypt {
  vault write --format=json transit/decrypt/$VAULT_KEY ciphertext=- | jq -r .data.plaintext | base64 -D
}

# encrypt data.
# Usage: encryptd "<data>"
function encryptd {
  echo $1 | _encrypt
}

# decrypt data.
# Usage: decryptd <ciphtertext>
function decryptd {
  echo -n $1 | _decrypt
}

# encrypt file. will overwrite existing ones! 
# Usage: encryptf <filename>
function encryptf {
  cat $1 | _encrypt > $1.enc
}

# decrypt file. will overwrite existing ones! 
# Usage: decryptf <filename>
function decryptf {
  cat $1 | _decrypt > `basename -s .enc $1`
}

# decrypt file and open for edit. on close encrypt changes.
# Usage: editcrypt <filename>
function editcrypt {
  cat $1 | _decrypt > $1.tmp &amp;&amp; $EDITOR $1.tmp &amp;&amp; cat $1.tmp | _encrypt > $1 &amp;&amp; rm $1.tmp
}
</code></pre>
<p>Sweeeeeett!</p>
<p>On thing to mention is adding the non-encrypted files to you <code>.gitignore</code>. This ensures the file wont end up in your repo by accident:</p>
<pre><code>$ cat .gitignore
# only checkin the encrypted version
/database.yml
/!database.yml.enc
</code></pre>
<p>I hope this helped setting up your own vault server. These are just the first rough steps. Vault allows way more, like very granular access management, various auth and storage backends etc. Again, I strongly recommend to check their docs https://vaultproject.io/docs and follow the interactive tutorial https://vaultproject.io/#/demo/0.c</p>
<p>Keep your data save!</p>
<p>[proofread by Daniel - thanks!]</p>
